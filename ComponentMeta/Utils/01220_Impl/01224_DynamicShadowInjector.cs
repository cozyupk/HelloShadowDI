using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using Cozyupk.HelloShadowDI.ComponentMeta.Attributes;
using Cozyupk.HelloShadowDI.ComponentMeta.Utils.Contracts;
using Unity;
using Unity.Lifetime;

namespace Cozyupk.HelloShadowDI.ComponentMeta.Utils.Impl
{
    /// <summary>
    /// A utility class for dynamically injecting dependencies into a Unity container
    /// by scanning assemblies for types marked with the ShadowInjectableAttribute.
    /// </summary>
    public class DynamicShadowInjector
    {
        /// <summary>
        /// Gets the default injection scope to be used when no specific scope is defined.
        /// </summary>
        public InjectionScope DefaultScope { get; }

        /// <summary>
        /// Gets the root path of the assemblies to be scanned for dependency injection.
        /// </summary>
        public string RootAssemblyPath { get; }

        /// <summary>
        /// A collection of diagnostic observers that can process diagnostic messages.
        /// </summary>
        private ConcurrentBag<IDiagnosticObserver> DiagnosticObservers { get; } = new ConcurrentBag<IDiagnosticObserver>();

        /// <summary>
        /// Analyzes assembly dependencies and generates a dependency graph.
        /// </summary>
        private AssemblyDependencyAnalyzer DependencyAnalyzer { get; } = new AssemblyDependencyAnalyzer();

        /// <summary>
        /// A static lock object used to ensure thread-safe operations when registering types
        /// into the Unity container. This prevents race conditions during concurrent access.
        /// </summary>
        private static object RegistrationLock { get; } = new object();

        /// <summary>
        /// A thread-safe cache for storing loaded assemblies, ensuring that the same assembly
        /// is not loaded multiple times. This improves performance and avoids potential conflicts
        /// caused by redundant loads.
        /// </summary>
        private static ConcurrentDictionary<string, Assembly?> AssemblyCache { get; } = new ConcurrentDictionary<string, Assembly?>();

        /// <summary>
        /// <summary>
        /// Initializes a new instance of the <see cref="DynamicShadowInjector"/> class.
        /// The constructor is marked as <c>protected internal</c> to restrict instantiation
        /// to the same assembly or derived classes, enforcing controlled construction via the corresponding builder.
        /// </summary>
        /// <param name="rootAssemblyPath">The root directory path containing the assemblies to scan.</param>
        /// <param name="defaultScope">The default injection scope to use if not specified in the attribute.</param>
        protected internal DynamicShadowInjector(string rootAssemblyPath, InjectionScope defaultScope = InjectionScope.Transient)
        {
            // Set the default scope and root assembly path
            DefaultScope = defaultScope;
            RootAssemblyPath = rootAssemblyPath;
        }

        /// <summary>
        /// Conditionally emits a diagnostic message only if observers are present.
        /// The message content is generated by invoking the supplied delegate,
        /// avoiding unnecessary string construction when no observers are registered.
        /// </summary>
        /// <param name="messageFactory">A delegate that appends message content to a list of strings.</param>
        /// <param name="level">The severity level of the diagnostic message. Defaults to <see cref="DiagnosticLevel.Info"/>.</param>
        protected internal virtual void OnBuildCompleted()
        {
            // This method can be overridden in derived classes to perform additional actions after the build is completed.

            // Notify observers about the successful construction of the DynamicShadowInjector.
            NotifyDiagnosticMessage($"[ShadowDI] DynamicShadowInjector successfully built.", DiagnosticLevel.Info);

            // Notify observers with a dependency graph if any observers are present.
            NotifyIfObserved(
                () => DependencyAnalyzer.GetDependencyGraph(),
                DiagnosticLevel.Trace
            );
        }

        /// <summary>
        /// Adds a diagnostic observer to the list of observers that will receive diagnostic messages.
        /// </summary>
        /// <param name="observer">The diagnostic observer to add.</param>
        public void AddDiagnosticObserver(IDiagnosticObserver observer)
        {
            DiagnosticObservers.Add(observer);
        }

        /// <summary>
        /// Sends a diagnostic message to all registered diagnostic observers.
        /// </summary>
        /// <param name="message">The diagnostic message to send.</param>
        /// <param name="level">The severity level of the diagnostic message. Defaults to Info.</param>
        protected void NotifyDiagnosticMessage(string message, DiagnosticLevel level = DiagnosticLevel.Info)
        {
            // Create a new diagnostic message with the provided content and severity level.
            var diagnostic = new DiagnosticMessage(message, level);

            // Initialize a list to collect exceptions that occur during observer notification.
            List<Exception> failures = new List<Exception>();

            // Iterate through all registered diagnostic observers.
            foreach (var observer in DiagnosticObservers)
            {
                try
                {
                    // Notify the observer with the diagnostic message.
                    observer.OnDiagnostic(diagnostic);
                }
                catch (Exception ex)
                {
                    // If an exception occurs, add it to the failures list and log the error.
                    failures.Add(ex);
                    Debug.WriteLine($"[ShadowDI] Observer failed: {ex.GetType().Name} - {ex.Message}");
                }
            }

            // If any observers failed, throw an aggregate exception containing all failures.
            if (failures.Count > 0)
            {
                throw new AggregateException("[ShadowDI] One or more diagnostic observers failed.", failures);
            }
        }

        /// <summary>
        /// Conditionally sends a diagnostic message to all registered observers, 
        /// only if at least one observer is present. The message is generated 
        /// by invoking a factory function that appends lines to a string list.
        /// </summary>
        /// <param name="messageFactory">A delegate that populates the message content using a list of strings.</param>
        /// <param name="level">The severity level of the diagnostic message. Defaults to <see cref="DiagnosticLevel.Info"/>.</param>
        protected void NotifyIfObserved(Func<List<string>> messageFactory, DiagnosticLevel level = DiagnosticLevel.Info)
        {
            // Check if there are no diagnostic observers registered; if none, exit early.
            if (DiagnosticObservers.Count == 0)
                return;

            // Initialize a list to collect exceptions that occur during observer notification.
            List<Exception> failures = new List<Exception>();

            // Generate diagnostic messages by invoking the provided message factory delegate.
            var lines = messageFactory();
            var messages = new List<DiagnosticMessage>(lines.Count);
            foreach (var line in lines)
            {
                // Create a diagnostic message for each line and add it to the list.
                messages.Add(new DiagnosticMessage(line, level));
            }

            // Iterate through all registered diagnostic observers.
            foreach (var observer in DiagnosticObservers)
            {
                // For each observer, send all generated diagnostic messages.
                foreach (var message in messages)
                {
                    try
                    {
                        // Notify the observer with the diagnostic message.
                        observer.OnDiagnostic(message);
                    }
                    catch (Exception ex)
                    {
                        // If an exception occurs, add it to the failures list and log the error.
                        failures.Add(ex);
                        Debug.WriteLine($"[ShadowDI] Observer failed: {ex.GetType().Name} - {ex.Message}");
                    }
                }
            }

            // If any observers failed, throw an aggregate exception containing all failures.
            if (failures.Count > 0)
            {
                throw new AggregateException("[ShadowDI] One or more diagnostic observers failed.", failures);
            }
        }

        /// <summary>
        /// Loads an assembly from the specified path using a thread-safe cache mechanism.
        /// This ensures that the same assembly is not loaded multiple times, improving performance
        /// and avoiding potential conflicts caused by redundant loads.
        /// </summary>
        /// <param name="path">The file path of the assembly to load.</param>
        /// <returns>
        /// The loaded <see cref="Assembly"/> object if successful; otherwise, <c>null</c> if the load fails.
        /// </returns>
        private Assembly? LoadAssemblyWithThreadSafeCache(string path)
        {
            // Use a thread-safe dictionary to cache loaded assemblies.
            return AssemblyCache.GetOrAdd(path, p =>
            {
                try
                {
                    // Attempt to load the assembly from the specified path.
                    return Assembly.LoadFrom(p);
                }
                catch (Exception ex)
                {
                    // Notify diagnostic observers about the failure to load the assembly.
                    NotifyDiagnosticMessage(
                        $"[ShadowDI] Failed to load assembly: {p} - {ex.Message}",
                        DiagnosticLevel.Warning
                    );
                    // Return null to indicate the failure.
                    return null;
                }
            });
        }

        /// <summary>
        /// Ensures thread-safe registration of a service type and its implementation type
        /// into the Unity container with the specified injection scope.
        /// </summary>
        /// <param name="container">The Unity container to register the types into.</param>
        /// <param name="serviceType">The interface or base type to register.</param>
        /// <param name="implementationType">The concrete type implementing the service type.</param>
        /// <param name="scope">
        /// The injection scope to use:
        /// <list type="bullet">
        ///   <item><description><see cref="InjectionScope.Singleton"/> – one shared instance</description></item>
        ///   <item><description><see cref="InjectionScope.Scoped"/> – one instance per logical scope</description></item>
        ///   <item><description><see cref="InjectionScope.Transient"/> – new instance per request</description></item>
        /// </list>
        /// </param>
        private void RegisterTypeThreadSafely(IUnityContainer container, Type serviceType, Type implementationType, InjectionScope scope)
        {
            // Lock to ensure thread-safe registration in the Unity container.
            lock (RegistrationLock)
            {
                switch (scope)
                {
                    case InjectionScope.Singleton:
                        // Register a single instance shared across the application.
                        container.RegisterSingleton(serviceType, implementationType);
                        break;

                    case InjectionScope.Scoped:
                        // Register a new instance for each scope using HierarchicalLifetimeManager.
                        container.RegisterType(serviceType, implementationType, new HierarchicalLifetimeManager());
                        break;

                    case InjectionScope.Transient:
                        // Register a new instance every time it is requested.
                        container.RegisterType(serviceType, implementationType);
                        break;

                    default:
                        // Handle unsupported or unspecified injection scopes.
                        throw new ArgumentOutOfRangeException(nameof(scope), $"Unsupported injection scope: {scope}");
                }
            }
        }

        /// <summary>
        /// Scans the specified assemblies for types marked with ShadowInjectableAttribute
        /// and registers them into the provided Unity container.
        /// </summary>
        /// <param name="container">The Unity container to register the dependencies into.</param>
        public void Inject(IUnityContainer container)
        {
            // Retrieve all .dll files from the specified root assembly path, including subdirectories.
            var assemblies = Directory.GetFiles(RootAssemblyPath, "*.dll", SearchOption.AllDirectories)
                                     .Select(path =>
                                     {
                                         // Use the thread-safe cache mechanism to load assemblies.
                                         return LoadAssemblyWithThreadSafeCache(path);
                                     })
                                     // Filter out any null entries resulting from failed loads.
                                     .Where(a => a != null)!;

            foreach (var assembly in assemblies)
            {
                // Array to hold the types defined in the current assembly.
                Type[] types;

                // Skip processing if the assembly is null.
                if (assembly == null) continue;

                try
                {
                    // Attempt to retrieve all types from the assembly.
                    types = assembly.GetTypes();
                }
                catch (ReflectionTypeLoadException ex)
                {
                    // Handle cases where some types fail to load by filtering out null entries.
                    types = ex.Types.Where(t => t != null).ToArray()!;
                }

                // Flag to track if any types were successfully registered.
                bool isRegistered = false;

                // Iterate through all types in the assembly.
                foreach (var type in types)
                {
                    // Check if the type is marked with the ShadowInjectableAttribute.
                    var attr = type.GetCustomAttribute<ShadowInjectableAttribute>();
                    if (attr == null) continue;

                    // Retrieve the service type and injection scope from the attribute.
                    var serviceType = attr.ServiceType;
                    var scope = attr.Scope != InjectionScope.Unspecified ? attr.Scope : DefaultScope;

                    // Register the type in the Unity container based on the specified scope.
                    switch (scope)
                    {
                        case InjectionScope.Singleton:
                            RegisterTypeThreadSafely(container, serviceType, type, InjectionScope.Singleton);
                            break;

                        case InjectionScope.Scoped:
                            RegisterTypeThreadSafely(container, serviceType, type, InjectionScope.Scoped);
                            break;

                        case InjectionScope.Transient:
                            RegisterTypeThreadSafely(container, serviceType, type, InjectionScope.Transient);
                            break;

                        default:
                            // Log a warning if the scope is unsupported.
                            NotifyDiagnosticMessage($"[ShadowDI] Unsupported scope: {scope} in {type.FullName}", DiagnosticLevel.Warning);
                            continue;
                    }

                    // Notify observers about the successful registration.
                    NotifyDiagnosticMessage($"[ShadowDI] Registered: {serviceType.Name} → {type.FullName} ({scope})", DiagnosticLevel.Info);
                    isRegistered = true;
                }

                // If no types were registered, skip further processing for this assembly.
                if (!isRegistered)
                {
                    continue;
                }

                // Notify observers with a dependency graph if any observers are present.
                NotifyIfObserved(
                    () => DependencyAnalyzer.GetDependencyGraph(assembly.FullName),
                    DiagnosticLevel.Trace
                );
            }
        }
    }
}